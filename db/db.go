// Package db is a wrapper around the mgo package the app uses to
// communicate with the MongoDB database.
package db

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"time"

	_ "github.com/lib/pq" // database/sql driver
	"github.com/nojnhuh/dotbook/models"
	"github.com/nojnhuh/dotbook/models/dotmath"
)

// session is a global variable that persists for the duration of the open
// connection. The app should only need one open connection at a time.
var db *sql.DB

// InitDB will open the app's connection to the database.
func InitDB() {
	dbUser := os.Getenv("DB_DB_USER")
	dbPassword := os.Getenv("DB_DB_PASSWORD")
	dbHostname := os.Getenv("DB_DB_HOST")
	dbName := dbUser
	connStr := fmt.Sprintf("user=%s password=%s dbname=%s host=%s sslmode=disable", dbUser, dbPassword, dbName, dbHostname)
	log.Println("Conn:", connStr)
	var err error
	db, err = sql.Open("postgres", connStr)
	if err != nil {
		log.Fatal(err)
	}

	for {
		err = db.Ping()
		if err == nil {
			break
		}
		time.Sleep(100 * time.Millisecond)
	}
	log.Printf("Connected to database %s at %s\n", dbName, dbHostname)

	_, err = db.Exec(`CREATE TABLE IF NOT EXISTS dotbooks (
		id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
		name text,
		field text
	);`)
	if err != nil {
		log.Fatal(err)
	}

	_, err = db.Exec(`CREATE TABLE IF NOT EXISTS dots (
		dotbook_id int GENERATED BY DEFAULT AS IDENTITY,
		name text,
		move_counts real,
		hold_counts real,
		x real,
		y real,
		body_center bool,
		prev text,
		primary key(dotbook_id, name)
	);`)
	if err != nil {
		log.Fatal(err)
	}
}

// CloseDB closes the app's connection with the database.
func CloseDB() {
	log.Println("Closing DB connection")
	db.Close()
}

// GetAllDotbooks queries the database and returns a Dotbook slice
func GetAllDotbooks() []*models.Dotbook {
	rows, err := db.Query(`SELECT id FROM dotbooks`)
	if err != nil {
		log.Fatal(err)
	}
	defer rows.Close()

	dbs := []*models.Dotbook{}

	for rows.Next() {
		var id int
		err = rows.Scan(&id)
		if err != nil {
			log.Fatal(err)
		}
		dotbook := GetDotbook(id)
		dbs = append(dbs, dotbook)
	}
	err = rows.Err() // get any error encountered during iteration
	if err != nil {
		log.Fatal(err)
	}

	return dbs
}

// GetDotbook retrieves a Dotbook object from the database via its id
func GetDotbook(id int) *models.Dotbook {
	var name string
	var fieldData []byte
	err := db.QueryRow(`SELECT name, field FROM dotbooks WHERE id = $1`, id).Scan(&name, &fieldData)
	if err == sql.ErrNoRows {
		return nil
	} else if err != nil {
		log.Fatal(err)
	}
	var field models.FieldLayout
	err = json.Unmarshal(fieldData, &field)
	if err != nil {
		log.Fatal(err)
	}

	rows, err := db.Query(`SELECT d.name, d.move_counts, d.hold_counts, d.x, d.y, d.body_center, d.prev FROM dots d JOIN dotbooks db ON db.id = d.dotbook_id WHERE d.dotbook_id = $1`, id)
	if err != nil {
		log.Fatal(err)
	}

	dots := []*models.Dot{}
	prevs := []string{}
	nameToDot := map[string]*models.Dot{}
	for rows.Next() {
		var dotName string
		var move float64
		var hold float64
		var x float64
		var y float64
		var bodyCenter bool
		var prevName string
		err = rows.Scan(&dotName, &move, &hold, &x, &y, &bodyCenter, &prevName)
		if err != nil {
			log.Fatal(err)
		}
		dot := &models.Dot{Name: dotName, MoveCounts: move, HoldCounts: hold, Point: dotmath.Point{X: x, Y: y}, BodyCenter: bodyCenter}
		dots = append(dots, dot)
		prevs = append(prevs, prevName)
		nameToDot[dotName] = dot
	}
	err = rows.Err() // get any error encountered during iteration
	if err != nil {
		log.Fatal(err)
	}

	for i, dot := range dots {
		if prevs[i] != "" {
			dot.PrevDot = nameToDot[prevs[i]]
		}
	}

	return &models.Dotbook{ID: id, Name: name, Field: &field, Dots: dots}
}

// DotbookExists returns a bool indicating whether or not a Dotbook with the
// given name is in the database
func DotbookExists(name string) bool {
	err := db.QueryRow(`SELECT * FROM dotbooks WHERE name = $1`, name).Scan(nil)
	return err != sql.ErrNoRows
}

// CreateDotbook inserts a Dotbook object in the database
func CreateDotbook(dotbook *models.Dotbook) {
	field, err := json.Marshal(dotbook.Field)
	if err != nil {
		log.Fatal(err)
	}

	var newDotbookID int
	err = db.QueryRow(`INSERT INTO dotbooks (name, field) VALUES ($1, $2) RETURNING id`, dotbook.Name, field).Scan(&newDotbookID)
	if err != nil {
		log.Fatal(err)
	}
	for _, dot := range dotbook.Dots {
		CreateDot(dot, newDotbookID)
	}
}

// DeleteDotbook deletes a Dotbook from the database
func DeleteDotbook(id int) error {
	return nil
}

// UpdateDotbook deletes a Dotbook from the database
func UpdateDotbook(id int, dotbook *models.Dotbook) error {
	return nil
}

// CreateDot inserts a Dot object in the database
func CreateDot(dot *models.Dot, dotbookID int) {
	prevName := ""
	if dot.PrevDot != nil {
		prevName = dot.PrevDot.Name
	}
	db.QueryRow(`INSERT INTO dots (dotbook_id, name, move_counts, hold_counts, x, y, body_center, prev) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`, dotbookID, dot.Name, dot.MoveCounts, dot.HoldCounts, dot.Point.X, dot.Point.Y, dot.BodyCenter, prevName)
}
